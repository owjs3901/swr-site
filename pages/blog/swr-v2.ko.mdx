---
image: https://assets.vercel.com/image/upload/v1670542323/swr/v2.png
description: 'Announcing SWR 2.0: new mutation APIs and improvd optimistic UI capabilities, new DevTools, better support for concurrent rendering, and more.'
date: December 9th, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

import Authors, { Author } from 'components/authors'
import Video from 'components/video'

# Announcing SWR 2.0

<Authors date="December 9th, 2022">
  <Author name="Shu Ding" link="https://twitter.com/shuding_" />
  <Author name="Jiachi Liu" link="https://twitter.com/huozhi" />
  <Author name="Toru Kobayashi" link="https://twitter.com/koba04" />
  <Author name="Yixuan Xu" link="https://twitter.com/yixuanxu94" />
</Authors>

우리는 SWR 2.0 릴리스 발표할 수 있게 돼 매우 흥분된다. SWR은 React 컴포넌트로 하여금 fetch, cache, 그리고 데이터 mutate를 통해 시간 변화에 따라 변하는 UI를 최신의 상태로 유지 시켜주는 인기있는 React 기반 data-fetching 라이브러리다.

새로운 버전에는 새로운 뮤테이션 API와 낙관적 갱신 패턴(Optimistic UI)에 관한 개선 뿐 아니라 DevTools, React의 병행 처리 기능 지원 등 다양한 개선과 새로운 기능이 포함돼 있다. 이 릴리스를 가능하게 해준 모든 컨트리뷰터와 메인테이너에 감사 인사를 전한다.

## 뮤테이션과 낙관적 UI 갱신

### useSWRMutation

뮤테이션은 데이터를 가져오는 과정에서 중요한 요소 중 하나다. 뮤테이션은 각 로컬과 원격 데이터의 갱신을 가능하게 한다. 기존 `mutate` API는 리소스 재검증 및 수동 업데이트를 지원했다. SWR 2.0에 새로 추가된 `useSWRMutation` 훅은 선언적인 API로, 보다 단순하게 원격 데이터를 갱신할 수 있도록 한다. 이 훅을 사용해 뮤테이션을 셋업 한 후 그 이후에 (필요한 시점 맞춰) 사용할 수 있다.

```jsx {11,16}
import useSWRMutation from 'swr/mutation'

async function sendRequest(url, { arg }) {
  return fetch(url, {
    method: 'POST',
    body: JSON.stringify(arg)
  })
}

function App() {
  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest)

  return (
    <button
      disabled={isMutating}
      onClick={() => trigger({ username: 'johndoe' })}
    >{
      isMutating ? 'Creating...' : 'Create User'
    }</button>
  )
}
```

위 예에서 `sendRequest`라는 `'/api/user'` 리소스에 영향을 주는 뮤테이션을 정의하고 있다. `useSWR`과는 달리 `useSWRMutation`은 렌더링 중에 즉시 요청하지 않는다. 대신에 나중에 수동으로 뮤테이션을 개시하기 위한 `trigger` 함수를 반환한다.

`sendRequest` 함수는 버튼이 클릭 됐을 때 추가 인수 `{ username: 'johndoe' }` 와 함께 호출된다. 값 `isMutating`은 뮤테이션이 종료 될 때 까지 `true`로 설정된다.

이에 더해, 새로운 훅은 뮤테이션과 관련된 기타 과제도 해결한다.

- 뮤테이션 중의 낙관적 UI 갱신
- 뮤테이션이 실패한 경우 자동으로 변경을 취소
- 동일한 리소스에 대한 `useSWR`이나 다른 뮤에티션과의 경쟁 상태 회피
- 뮤테이션이 완료된 뒤 `useSWR` 캐시에 데이터를 반영
- ...

이 API에 대한 상세한 참조나 예제는 [문서](https://swr.vercel.app/docs/mutation#useswrmutation) 또는 스크롤하여 이어지는 몇몇 절을 살펴본다.

### 낙관적 UI 갱신

낙관적 UI 갱신은 빠르고 반응이 좋은 웹사이트를 만들기 위한 훌륭한 모델이다. 그러나 올바르게 구현하는 것은 어렵다. SWR 2.0에서는 이를 간단하게 해결할 수 있는 옵션을 추가했다.

할 일 목록에 새로운 할 일을 추가하기 위한 API가 있고, 이를 이용해 서버에 데이터를 송신하는 경우를 살펴보자.

```jsx
await addNewTodo('New Item')
```

이 UI에서는 할 일 목록을 표시하기 위해 `useSWR` 훅을 사용하고 있으며 `mutate()`를 통해 서버에 요청하고 SWR에 다시 가져오기 위한 "Add New Item" 버튼이 있다.

```jsx {7,8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={async () => {
    await addNewTodo('New Item')
    mutate()
  }}>
    Add New Item
  </button>
</>
```

이때 `await addNewTodo(...)`에 의한 요청에 시간이 걸리는 경우가 있다. 새로운 목록이 어떻게 표시될지 충분히 알고 있어도 요청을 실행하는 중 사용자에게는 이전 상태의 목록을 계속 표시하게 된다. 새로운 `optimisticData` 옵션을 사용하여 서버가 응답하기 전에 새로운 상태 목록을 낙관적 UI로서 표시할 수 있다.

```jsx {8}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
    })
  }}>
    Add New Item
  </button>
</>
```

SWR은 즉시 `data`를 `optimisticData` 값으로 갱신하고 서버에 요청을 송신한다. 요청이 완료되면 SWR은 리소스를 재검증하여 데이터가 최신임을 보증한다.

다른 여러 API 처럼 `addNewTodo(...)`가 최신 결과를 서버로부터 반환받을 경우 우리는 그 결과를 (재검증하는 대신에) 그대로 표시할 수도 있다. 새로운 `populateCache` 옵션은 SWR에 로컬 데이터를 뮤테이션 응답으로 갱신할 것을 전달하는 옵션이다.

```jsx {9}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
    })
  }}>
    Add New Item
  </button>
</>
```

동시에 응답 데이터가 올바른 데이터인 경우에는 재검증이 필요하지 않다. `revalidate` 옵션으로 재검증을 비활성화할 수 있다.

```jsx {10}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
      revalidate: false,
    })
  }}>
    Add New Item
  </button>
</>
```

마지막으로, 혹시 `addNewTodo(...)`가 예외로 실패한 경우, `rollbackOnError` 옵션을 `true`(기본 옵션)로 설정하여 낙관적 갱신으로서 설정한 데이터 `([...data, 'New Item'])`를 취소할 수 있다. 그것이 발생한 경우, SWR은 `data`가 갱신되기 전의 데이터로 되돌린다.

```jsx {11}
const { mutate, data } = useSWR('/api/todos')

return <>
  <ul>{/* Display data */}</ul>

  <button onClick={() => {
    mutate(addNewTodo('New Item'), {
      optimisticData: [...data, 'New Item'],
      populateCache: true,
      revalidate: false,
      rollbackOnError: true,
    })
  }}>
    Add New Item
  </button>
</>
```

이 모든 API는 새로운 useSWRMutation 에서도 동일하게 지원하고 있다. 추가 정보는 [문서](https://swr.vercel.app/docs/mutation#optimistic-updates)에서 확인할 수 있다. 아래 데모를 통해 이러한 동작 과정을 살펴볼 수 있다.

<Video
  src="/video/optimistic-ui.mp4"
  caption="Optimistic UI with automatic error rollback"
  ratio={223/584}
/>

### 다중 키 뮤테이션

글로벌 `mutate` API가 필터 함수를 받을 수 있게 돼 특정 키에 대한 뮤테이트 또는 재검증이 가능하다. 이 기능은 모든 캐시 데이터를 무료화 하는 등의 경우 편리하게 사용할 수 있다. 자세한 내용은 문서 [Mutate Multiple Items](https://swr.vercel.app/docs/mutation#mutate-multiple-items)에서 확인한다.

```jsx
import { mutate } from 'swr'
// 또는 캐시 프로바이더를 사용자 정의하고 있는 경우에는 훅을 통해
// { mutate } = useSWRConfig()

// 단일 리소스를 뮤테이트 한다.
mutate(key)

// 여러 리소스를 뮤테이트하여 캐시를 비운다(undefined을 설정한다)
mutate(
  key => typeof key === 'string' && key.startsWith('/api/item?id='),
  undefined,
  { revalidate: false }
)
```

## SWR DevTools

[SWRDevTools](https://swr-devtools.vercel.app)는 브라우저 확장으로, SWR 캐시나 가져오기 결과를 디버깅하는데 도움을 준다. 애플리케이션에서의 사용 방법은 [개발자도구](https://swr.vercel.app/docs/advanced/devtools) 섹션을 참고한다.

![](/img/devtools/cache-view.jpg)

## 데이터 미리 가져오기

데이터 미리 가져오기는 사용자 경험을 극적으로 개선한다. 혹시 리소스가 나중에 사용될 것을 알고 있는 경우 `preload` API를 사용하여 가져오기를 사전에 실행 할 수 있다.

```jsx {6}
import useSWR, { preload } from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

// preload 함수는 어디서든 호출할 수 있다.
preload('/api/user', fetcher)

function Profile() {
  // 실제 컴포넌트 내에서 데이터를 갱신한다.
  const { data, error } = useSWR('/api/user', fetcher)
  // ...
}

export function Page () {
  return <Profile/>
}
```

위 예에서 `preload` API는 전역 스코프 내에서 호출하고 있다. 이는 리소스를 리액트 렌더링을 시작하기 전에 미리 가져오고 있음을 의미한다. 이에 의해 `Profile` 컴포넌트가 렌더링 될 때 데이터는 이미 사용할 수 있는 상태다. 만약 요청이 아직 실행 중이라면 `useSWR` 훅은 새로운 요청을 시작하는 게 아니라 실행 중인 사전 가져오기 요청을 재사용한다.

`preload` API는 나중에 표시될 페이지의 데이터를 사전에 가져오기 위한 경우 등에도 사용할 수 있다. SWR을 사용한 미리 가져오기와 관련한 추가 정보는 문서 [Prefetching Data](https://swr.vercel.app/docs/prefetching)에서 확인한다.

## `isLoading`

`isLoading`은 `useSWR`에서 반환되는 새로운 상태로 **요청이 아직 실행 중으로 가져온 데이터가 아직 없는 것**을 나타낸다. 지금까지의 `isValidating`은 초기 로딩과 재검증 상태를 모두 나타냈기 때문에 초기 로딩 여부를 알기 위해서는 `data`와 `error`가 `undefined`인지 검사해야 했다.

이제는 `isLoading`을 그대로 사용하여 간단하게 로딩 메시지를 표시할 수 있다.

```jsx
import useSWR from 'swr'

function Profile() {
  const { data, isLoading } = useSWR('/api/user', fetcher)

  if (isLoading) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
```

앞으로도 `isValidating`은 제공되며 재검증 시의 로딩을 표시하기 위해 사용할 수 있다는 점에 주의하길 바란다.

<Callout emoji="📝">
  이번에 SWR이 어떻게 값을 반환하는지 설명하는 [Understanding SWR](https://swr.vercel.app/docs/advanced/understanding) 페이지를 새로 추가했다. 이 페이지에서는 `isValidating`과 `isLoading`의 차이나 이를 조합해 어떻게 사용자 겸헝을 향상 시킬 수 있는지 설명돼 있다.
</Callout>

## 이전 상태를 보존하기

`keepPreviousData`는 새로 추가된 옵션으로 이전에 가져온 데이터를 보존한다. 이는 실시간 검색과 같이 리소스의 `key`가 계속 변화해 사용자 액션에 따라 매번 데이터를 가져오는 경우에 UX를 극적으로 향상시킨다.

```jsx {5}
function Search() {
  const [search, setSearch] = React.useState('');

  const { data, isLoading } = useSWR(`/search?q=${search}`, fetcher, {
    keepPreviousData: true
  })

  return (
    <div>
      <input
        type="text"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder="Search..."
      />

      <div className={isLoading ? "loading" : ""}>
        {data?.products.map(item => <Product key={item.id} name={item.name} />)
      </div>
    </div>
  );
}
```

<Video
  src="https://user-images.githubusercontent.com/3676859/163695903-a3eb1259-180e-41e0-821e-21c320201194.mp4"
  caption="keepPreviousData가 활성화된 경우에 이전 결과를 유지하고 있는 모습"
  ratio={640/730}
/>

자세한 것은 [CodeSandbox](https://codesandbox.io/s/swr-keeppreviousdata-fsjz3m)의 코드와 [문서](https://swr.vercel.app/docs/advanced/understanding#return-previous-data-for-better-ux)를 참고한다.

## Extending Configurations

`SWRConfig`는 함수를 값으로 전달할 수 있도록 됐다. 여러 레벨에서 `<SWRConfig>`를 갖고 있는 경우 내부 컴포넌트는 부모의 설정을 전달받아 새로운 설정을 반환한다. 이것은 대규모 코드 베이스에서 유연한 SWR 설정을 가능하게 한다. 자세한 내용은 [공식 가이드 문서](https://swr.vercel.app/docs/global-configuration)를 확인한다.

```jsx
<SWRConfig
  value={parentConfig => ({
    dedupingInterval: parentConfig.dedupingInterval * 5,
    refreshInterval: 100,
  })}
>
  <Page />
</SWRConfig>
```

## React 18 지원 개선

SWR은 내부 구현에서 `useSyncExternalStore`나 `startTransition`과 같은 React 18에서 추가된 API를 사용하게 됐다. 이는 UI 렌더링이 병행 처리가 되는 경우에 있어서도 일관성을 보장해 준다. 이를 통해 사용자의 구현을 변경할 필요 없이 모든 개발자가 혜택을 받을 수 있다. 그리고 React 17 이나 오래된 버전을 위한 구현도 포함돼 있다.

SWR 2.0과 모든 새로운 기능은 React 16이나 17에 대해서도 계속해서 호환성을 갖는다.

## 이전 가이드

### fetcher가 더 이상 복수 인수를 허용하지 않음

`key`는 단일 인수로서 전달된다.

```diff
- useSWR([1, 2, 3], (a, b, c) => {
+ useSWR([1, 2, 3], ([a, b, c]) => {
  assert(a === 1)
  assert(b === 2)
  assert(c === 3)
})
```

### 전역 뮤테이션 API가 더 이상 `getKey` 함수를 허용하지 않음

만약 전역 `mutate`에 함수를 전달한 경우 [필터](/blog/swr-v2#mutate-multiple-keys) 함수로 사용된다. 지금까지는 전역 `mutate`에 키를 반환하는 함수를 전달할 수 있었다.

```diff
- mutate(() => '/api/item') // 키를 반환하는 함수
+ mutate('/api/item')       // 직접 키를 전달한다
```

### 캐시 인터페이스에 새 필수 속성 `keys()` 추가

자체 캐시 구현을 사용하고 있는 경우, 캐시 인터페이스로 자바스크립트의 `Map`처럼 캐시의 모든 키를 반환하는 `keys()` 메서드가 필수로 필요하다.

```diff
interface Cache<Data> {
  get(key: string): Data | undefined
  set(key: string, value: Data): void
  delete(key: string): void
+ keys(): IterableIterator<string>
}
```

### 캐시의 내부 구조가 변경됨

캐시의 내부 구조가 모든 상태를 보존하는 단일 객체로 변경됐다.

```diff
- assert(cache.get(key) === data)
+ assert(cache.get(key) === { data, error, isValidating })

// getter
- cache.get(key)
+ cache.get(key)?.data

// setter
- cache.set(key, data)
+ cache.set(key, { ...cache.get(key), data })
```

<Callout emoji="🚨" type="error">
  캐시에 대해 직접 데이터를 작성해서는 안 된다. 예기치 않은 동작이 발생할 수 있다.
</Callout>

### `SWRConfig.default`가 `SWRConfig.defaultValue`로 이름 변경됨

`SWRConfig.defaultValue`는 기본 SWR 설정에 접근하기 위한 속성이다.

```diff
- SWRConfig.default
+ SWRConfig.defaultValue
```

### Type `InfiniteFetcher` Is Renamed as `SWRInfiniteFetcher`

```diff
- import type { InfiniteFetcher } from 'swr/infinite'
+ import type { SWRInfiniteFetcher } from 'swr/infinite'
```

### 서버 상의 서스펜스를 이용한 데이터 가져오기를 피함

SWR을 `suspense: true`와 함께 서버 상에서 사용하고 싶은 경우(Next.js에 의한 사전 렌더링도 포함), [`fallbackData` 또는 `fallback`](/docs/with-nextjs#pre-rendering-with-default-data)에 의한 초기 데이터가 반드시 제공돼야 한다. 이는 현시점 서스펜스를 사용한 데이터 취득은 서버 상에서 실행할 수 없다는 것을 의미한다. 다른 두 가지 옵션으로는 완전히 클라이언트 상에서 데이터를 가져오거나 프레임워크를 통해 데이터를 가져오는 방법(Next.js의 getStaticProps와 같은)이 있다.

### 빌드 타켓이 ES2018로 변경됨

IE11을 지원하고 싶은 경우, 프레임워크나 번들러에서 ES5 빌드 타겟으로 설정해야 한다. 이 변경으로 SSR 시의 성능 및 번들 크기를 개선했다.

## 변경 이력

전체 변경 이력은 [깃허브](https://github.com/vercel/swr/releases)에서 확인할 수 있다.

## 향후 및 감사 인사

새로운 [Next.js 13](https://nextjs.org/blog/next-13) 릴리스에서는 흥미로운 다양한 신기능 뿐 아니라 [React Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components)나 스트리밍 SSR, [비동기 컴포넌트](https://beta.nextjs.org/docs/data-fetching/fetching#asyncawait-in-server-components), [`use` 훅](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#usepromise) 등 React 생태계에 따른 패러다임 전환이 있었다.

그렇지만 SWR 프로젝트의 목표(goal)는 계속 변하지 않는다. 우리는 경량으로 도입 가능하며 프레임워크에 의존하지 않고, 조금은 _완고한_ 방식(예: 포커스 시 재검증)을 목표로 하고 있다. 표준적인 솔루션이 되는 것을 목표로 하는 대신, 보다 나은 사용자 경험을 실현하기 위한 혁신에 집중하고자 한다. 한편 우리는 React의 새로운 힘을 이용해 어떻게 SWR을 개선할 수 있을지 조사하고 있다.

[143](https://github.com/vercel/swr/graphs/contributors)명의 컨트리뷰터(+[106](https://github.com/vercel/swr-site/graphs/contributors)의 문서 컨트리뷰터) 그리고 협력해 주신 모든분, 피드백을 주신 모든 분에게 감사드린다. [Toru Kobayashi](https://twitter.com/koba04)의 DevTools와 문서에 대한 작업에 특별한 감사를 올린다. 그의 도움 없이는 이 릴리스는 실현할 수 없었을 것이다.
